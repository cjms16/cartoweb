<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin=""/>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <!-- Pour le routing : -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <link rel="icon" href="assets/favicon.png">

    <title>CartoWeb - Projet</title>
    <style>
        #map {
            height: 850px; width: 100%;
            border: 1px solid black;
        }
        /* Pour cacher la box avec les consignes de navigation */
        .leaflet-routing-container {
            display: none;
        }
    </style>

</head>
<body>
    <!-- JS de  Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>

    <!-- JS du Routing Leaflet -->
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.AnimatedMarker/1.0.0/AnimatedMarker.min.js" integrity="sha512-Ir8s06d1S4H5J8LmeAHblNVEPkyYgA5AmOUba/xlNbFGTeDRqxAMBE1jp5PycEwKZ6FzuYsj22q/sDs0LCuSrA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="cartoweb_functions.js"></script>

    <div class="container-fluid">
        <div class="row">
            <div class="col-9" id="left-div">
                <div id="map"></div>
            </div>
            <div class="col-3" id="right-div">
                <img src="assets/logo-off.png" alt="logo-titre">
                <p id="position-display"></p>
                <p id="hexagon-display"></p>

                <div class="container-fluid form-group">
                    <button id="btn-relancer-animation" class="btn btn-primary">Relancer</button>
                </div>
                <div class="container-fluid form-group">
                    <label for="num-routes" class="col-form-label">Nombre d'itinéraires:</label>
                    <select id="num-routes" class="form-control">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                    </select>
                    <br>
                    <button id="btn-start-animation" class="btn btn-success disabled">Démarrer</button>
                    <button id="btn-pause-animation" class="btn btn-secondary disabled">Pause</button>
                    <button id="btn-stop-animation" class="btn btn-danger">Stopper</button>
                </div>
            </div>
        </div>
    </div>

    <script>

    const CENTRE_MULHOUSE = { lat: 47.7496926, lng: 7.3372857 };
    const RAYON_ZONE_DEPLACEMENT = 3;
    const VITESSE_DEPLACEMENT = 1000;

    //Initilisation du fond de carte
    var map = L.map('map').setView([CENTRE_MULHOUSE.lat, CENTRE_MULHOUSE.lng], 13);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);
    
    //Maillage du territoire
    const corner1 = L.latLng(47.787327, 7.253229);
    const corner2 = L.latLng(47.705142, 7.430711);
    var grille_mulhouse = L.latLngBounds(corner1, corner2);
    var maillage = createHexGrid(grille_mulhouse, 0.005);
    var tableauIndexAVerdir = [];

    const numOfVehicles = 10;
    var polygons = [];

    // // Créer des polygones et les stocker dans le tableau polygons
    // for (var i = 0; i < maillage.length; i++) {
    //     var polygon = maillage[i];
    //     polygon.properties = { hasVehicle: false };
    //     polygons.push(polygon);
    // }

    for (let i = 0; i < numOfVehicles; i++) {
        // Génère des points de départ et d'arrivée aléatoires dans les zones définies
        var startPoint = getRandomPointInBounds(grille_mulhouse);
        var endPoint = getRandomPointInBounds(grille_mulhouse);

        // Crée un nouvel itinéraire
        const routeControl = L.Routing.control({
            waypoints: [startPoint, endPoint],
            show: false,
            lineOptions: {
                styles: [{
                    color: 'purple',
                    opacity: 0.7
                }]
            }
        }).addTo(map);

        routeControl.on('routeselected', function(e) {
            var route = e.route;
            routeArray = route.coordinates;

            let voiture1 = L.animatedMarker(
                routeArray,
                {
                    distance: 1000, // Distance parcourue en millisecondes
                    interval: 200, // Intervalle entre les positions en millisecondes
                    icon: L.icon({
                        iconUrl: 'assets/marker-icon.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        shadowSize: [41, 41],
                        shadowAnchor: [12, 41],
                        iconBorderColor: '#444'
                    }),
                    autoStart: true, // Démarrer automatiquement l'animation
                    opacity: 0.5,
                    onEnd: function() {
                        console.log("Trajet terminée !");
                        }
                }
            );
            voiture1.addTo(map);
            let voiture1_index = 0;

            // // Vérifier si le véhicule est dans un polygone et mettre à jour la propriété hasVehicle
            // polygons.forEach(function(polygon) {
            //     var latlng = L.latLng(voiture1.getLatLng().lat, voiture1.getLatLng().lng);
            //     if (L.polygon(polygon.geometry.coordinates).contains(latlng)) {
            //         polygon.properties.hasVehicle = true;
            //     }
            // });

            // // Mettre à jour la couleur de chaque polygone en fonction de la propriété hasVehicle
            // polygons.forEach(function(polygon) {
            //     var color = polygon.properties.hasVehicle ? 'green' : 'gray';
            //     polygon.setStyle({ color: color });
            // });

            // //MAJ la position de l'animated marker sur le volet stat && MAJ couleur polygones
            // function updatePositionDisplay() {
            //     var coords = voiture1.getLatLng();
            //     document.getElementById("position-display").innerHTML = "Latitude : " + coords.lat + ", Longitude : " + coords.lng;
            // }

            function updateHexagonColor() {
                if(!isMarkerInsidePolygon(voiture1, maillage[voiture1_index])) {
                    for (let i = 0; i < maillage.length; i++) {
                        if(isMarkerInsidePolygon(voiture1, maillage[i])) {
                            //SUPPRESSION DU TABLEAU
                            const index = tableauIndexAVerdir.indexOf(voiture1_index);
                            if (index > -1) { // only splice array when item is found
                                tableauIndexAVerdir.splice(index, 1); // 2nd parameter means remove one item only
                            }
                            //REMPLACEMENT VOITURE
                            voiture1_index = i;
                            //AJOUT NOUVELLE VALEUR
                            tableauIndexAVerdir.push(voiture1_index);
                        }
                    }
                }
                console.log('tableaux : '+tableauIndexAVerdir);
            }

            // // maj de la position toutes les 0.1 secondes
            // setInterval(updatePositionDisplay, 100);
            setInterval(updateHexagonColor, 100);
            
            

            var stopButton = document.getElementById("btn-stop-animation");

    // // Ajout d'un écouteur d'événements sur le bouton "Stopper"
    // stopButton.addEventListener("click", function() {

    //     // Suppression de tous les `animatedMarker` de la carte
    //     animatedMarker.forEach(function(marker) {
    //         map.removeLayer(marker);
    //     });

    //     // Suppression de tous les `Routing.control` de la carte
    //     Routing.control().forEach(function(control) {
    //         map.removeControl(control);
    //     });

    // });

        });

        
    }

    console.log(tableauIndexAVerdir);

    // Récupération du bouton "Stopper"
    

    setInterval(colorierMaillage, 100);
    /*
    Toutes les 0.1s
    Pour chaque vehicule
        le localiser dans un polygone (fonction qui retourne l'index du polygone dans lequel il est)
    On obtient alors un tableau avec les index à colorier en vert (on fait en sorte de prendre un tableau js qui ignore
                                                        les nombres déjà present dans le tableu : set on qque chose du style)
    Fonction qui colorie le tableau avec un if l'index du tableau dans le tableau des 



    2e methode : 
        que le marker garde son index avec lui et le comparer a chaque rafraichissement
                Si pas le même mettre à jour le tableau des index à colorier
    */

    </script>
</body>
</html>